<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>3rd HomeWork</title>
    <style>
      body {
        padding: 2rem;
      }
      div {
        text-align: start;
      }
      .task {
        margin: 15px;
      }
    </style>
  </head>
  <body>
    <div>
      <div class="task">
        <h1>Домашнее Задание №2</h1>
        <p1>
          <strong>Первая задача:</strong> Написать свою реализацию встроенной
          функции массивов filter. Назвать функцию myFilter и сделать так, чтобы
          любой массив мог использовать данную функцию как "родную". В качестве
          параметров он должен принимать callback-функцию и как необязательный
          параметр объект, который будет использован в качестве this в рамках
          внутренних вызовов данной callback-функции. В конечном итоге ваша
          реализация myFilter должна работать точно также как и встроенный метод
          filter. Callback-функция, переданная в качестве параметра, также
          должна вызываться с теми же параметрами, что и оригинал (элемент,
          индекс, массив).
        </p1>
      </div>
      <div class="task">
        <p1>
          <strong>Вторая задача:</strong>Написать функцию
          createDebounceFunction. Она должна принимать два аргумента:
          callback-функцию и задержку в миллисекундах. Данная функция должна
          возвращать новую функцию, вызывающую callback-функцию с задержкой в
          переданное количество миллисекунд. ПРИ ЭТОМ! Если за то время, пока
          внутрення callback-функция ждёт своего вызова, наша созданная функция
          вызывается ещё раз, то "счётчик" времени должен сбрасываться и
          начинаться заново (т.е. вызова внутренней функции произойти не
          должно).<br />
          > Пример:<br />
          const log100 = () => console.log(100);<br />
          const debounceLog100 = createDebounceFunction(log100, 1000);<br />
          debounceLog100();<br />
          setTimeout(debounceLog100, 200); // так как задержка в 1000мс и новый
          вызов этой же функции происходит через 200 миллисекунд, то таймер
          запускается заново<br />
          setTimeout(debounceLog100, 400); // снова сбрасываем таймер ещё через
          200 миллисекунд<br />
          Вывод в консоли значения 100 примерно через 1000мс + 200мс + 200мс<br />
        </p1>
      </div>
    </div>
    <script src="script.js"></script>
  </body>
</html>
